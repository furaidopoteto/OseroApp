<!DOCTYPE html>
<html lang="ja">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>オセロ</title>
        <style>
            body{
                background-color: gray;
            }
            #box{
                height: 700px;
                width: 700px;
                margin: 0 auto;
            }
            .subbox{
                border: 1px solid black;
                text-align: center;
                width: 12%;
                height: 12%;
                display: inline-block;
                background-color: green;
            }
            .buttons{
                border-radius: 150px;
                background-color: green;
                height: 80%;
                width: 80%;
            }
            .onanimation{
                background-color: red;
                animation: 1s linear alternate infinite masuanimation;/* alternateで100%から折り返す 参考: https://sunsukeblog.com/css_animation_keyframe */
            }
            .onanimation:hover{
                background-color: aqua;
            }
            @keyframes masuanimation{
                0% {opacity: 0.4;}
                100% {opacity: 1;}
            }
            .cpucheckmasu{
                background-color: blue !important;
                animation: .5s linear infinite cpucheckanimation;
            }
            @keyframes cpucheckanimation{
                0% {opacity: 0.1;}
                100% {opacity: 1;}
            }
            .header{
                position: fixed;
            }
            .headertitle, #select, .result, #modeselect, #nowturnname, .resetbutton, #orderselect{
                font-size: 45px;
            }
            #orderselect{
                margin-top: 25px;
            }
            .resetbutton{
                margin-top: 120px;
                display: inline-block;
                text-decoration: none;
                color: black;
                transition: .5s ease;
            }
            .resetbutton:hover{
                box-shadow: 10px 10px;
                background-color: #39ff14;
            }
            .onresetanimation{
                animation: alternate 1s linear infinite resetbuttonanimation;
            }
            @keyframes resetbuttonanimation{
                0% {
                    
                }
                100% {
                    box-shadow: 5px 5px;
                    background-color: #39ff14;
                }
            }
            
            #cpupercent{
                font-size: 45px;
            }
            #percentbox{
                width: 300px;
                height: 50px;
                border: 1px solid black;
                border-radius: 100px;
            }
            #percent{
                transition: .5s ease;
                height: 100%;
                display: inline-block;
                background-color: #21cbff;
                border-radius: 100px;
            }

            #selectsecond{
                text-align: right;
                position: absolute;
                top: 10px;
                right: 0;
                font-size: 30px;
            }
            #bluesecond{
                font-size: 30px;
            }
        </style>
    </head>
    <body>
        <span id="selectsecond">青色点滅時間<br><input onchange="selectsecond()" type="number" id="bluesecond" value="2000" min="10" max="10000">ミリ秒</span>

        <div class="header">
            <span id="nowturnname"></span><br>
            <span id="cpupercent"></span><img id="loadingimg" src="" alt=""><br>
            <span class="result"></span><br>
            <span class="headertitle">現在の駒は</span>
            <select id="select" name="select" onchange="change()">
                <option value="白">白</option>
                <option value="黒">黒</option>
            </select>
            <span class="headertitle">です</span><br>
            <span class="headertitle">CPUモード</span><br>
            <select id="modeselect" name="cpuselect" onchange="modechange()">
                <option value="true">ON(ランダム)</option>
                <option value="AItrue">ON(少し強い)</option>
                <option value="false">OFF</option>
            </select><br>
            <select name="orderselect" id="orderselect" onchange="Fistorderchange()">
                <option value="First">先行</option>
                <option value="Second">後攻</option>
            </select><br>
            <a href="javascript:reset()" class="resetbutton">リスタート</a>
        </div>
        <div id="box"></div>
        <script src="./jquery-3.5.1.min.js"></script>
        <script>
            'use strict';

            const box = document.getElementById('box');
            const startnumber = [27, 28, 35, 36];
            const select = document.getElementById('select');
            const modeselect = document.getElementById('modeselect');
            const nowturnname = document.getElementById("nowturnname");
            const cpupercent = document.getElementById("cpupercent");
            const loadingimg = document.getElementById('loadingimg');
            const orderselect = document.getElementById('orderselect');
            const bluesecond = document.getElementById('bluesecond');

            let order = "白";
            let masucheckbool = false;//打てるマスかどうかの判定用変数
            let whitehantei = false;//間が黒かどうかを判定する変数
            let blackhantei = false;//間が白かどうかを判定する変数
            let round = 1;//現在どっちのターンかを判別するための数値
            let cpumode = true;
            let sleep = 1000*2;//CPUの駒の青色表示の点滅時間
            let skip = false;
            let Priority = [30, -12, 0, -1, -1, 0, -12, 30,
            -12, -15, -3, -3, -3, -3, -15, -12,
            0, -3, 0, -1, -1, 0, -3, 0,
            -1, -3, -1, -1, -1, -1, -3, -1,
            -1, -3, -1, -1, -1, -1, -3, -1,
            0, -3, 0, -1, -1, 0, -3, 0,
            -12, -15, -3, -3, -3, -3, -15, -12,
            30, -12, 0, -1, -1, 0, -12, 30];


            let Board = [];

            let redmasu = [];
            let AImode  = false;
            let cpustudy = false;

            let fastturn = true;

            let Firstorder = "First";
            let orderchecknumber = 0;//0の場合は先行、1の場合は後攻

            let selectsecond = () => {
                let num = new Number(bluesecond.value);
                if(num <= 10){
                    num = 10;
                }
                if(num > 10000){
                    num = 10000;
                }
                sleep = num;
                bluesecond.value = num;
                console.log(sleep)
            }

            //駒を変更する関数
            let change = () => {
                order = select.value;
                masucheck();
            }

            //モードをチェンジする関数
            let modechange = () => {
                if(modeselect.value == "AItrue"){
                    AImode = true;
                    cpumode = true;
                }else{
                    cpumode = (modeselect.value == "true") ? true:false;//文字列から真理値に変換
                    AImode = false;
                }
                if(cpumode || AImode){
                    nowturnname.textContent = "あなたのターン";
                    orderselect.disabled = false;
                }else{
                    nowturnname.textContent = "";
                    orderselect.disabled = true;
                }
            }

            //先行か後攻かをチェンジする関数
            let Fistorderchange = () => {
                Firstorder = orderselect.value;
                if(Firstorder == "First"){
                    orderchecknumber = 0;
                }else{
                    orderchecknumber = 1;
                }
                if(cpumode || AImode){
                    cpuoperation();
                }
            }

            //オセロの盤面を生成する関数
            let createbox = () => {
                let count = 0;
                let xcount = 0;
                let ycount = 0;
                for(let i = 0;i<8*8;i++){
                    box.insertAdjacentHTML("beforeend", `<div class="subbox"><button class="buttons ycount${ycount} xcount${xcount}" id="number${i}" onclick="viewclick(${i}, ${ycount}, ${xcount})"></button></div>`);
                    xcount++;
                    if(xcount > 7){
                        xcount = 0;
                        ycount++;
                    }
                    if(startnumber.indexOf(i) >= 0){
                        const number = document.getElementById(`number${i}`);
                        switch(count){
                            case 0: number.style.backgroundColor = "white";
                                    break;
                            case 1: number.style.backgroundColor = "black";
                                    break;
                            case 2: number.style.backgroundColor = "black";
                                    break;
                            case 3: number.style.backgroundColor = "white";
                                    break;
                        }
                        count++;
                    }
                }
                for(let i = 0;i<64;i++){
                    const number = document.getElementById(`number${i}`);
                    if(number.style.backgroundColor == "white"){
                        Board.push(1);
                    }else if(number.style.backgroundColor == "black"){
                        Board.push(2);
                    }else if($(`#number${i}`).css("background-color") == "rgb(0, 128, 0)"){
                        Board.push(0);
                    }else{
                        Board.push(0);
                    }
                }
                masucheck();
            }

            //マスの色を変える関数
            let masuchange = (number, ycount, xcount, checkonly) => {
                if(!cpustudy){//CPUが学習中じゃない場合は現在の駒の状況を数値で配列に格納
                    Board = [];
                    for(let i = 0;i<64;i++){
                        const number = document.getElementById(`number${i}`);
                        if(number.style.backgroundColor == "white"){
                            Board.push(1);
                        }else if(number.style.backgroundColor == "black"){
                            Board.push(2);
                        }else if($(`#number${i}`).css("background-color") == "rgb(0, 128, 0)"){
                            Board.push(0);
                        }else{
                            Board.push(0);
                        }
                    }
                }
                
                yminus(number, ycount, xcount, checkonly);//第4引数はクリックなのか打てるマスの判定のみなのかを決める真理値
                yplus(number, ycount, xcount, checkonly);
                xminus(number, ycount, xcount, checkonly);
                xplus(number, ycount, xcount, checkonly);
                BottomLeft(number, ycount, xcount, checkonly);
                UpperRight(number, ycount, xcount, checkonly);
                BottomRight(number, ycount, xcount, checkonly);
                UpperLeft(number, ycount, xcount, checkonly);

                if(!cpustudy){//CPUが学習中じゃない場合は配列の数値に応じてマスの色を変更
                    for(let i = 0;i<64;i++){
                        const number = document.getElementById(`number${i}`);
                        if(Board[i] == 1){
                            number.style.backgroundColor = "white";
                        }else if(Board[i] == 2){
                            number.style.backgroundColor = "black";
                        }
                    }
                }
            }


            //クリックされたら盤面を変更する関数
            let viewclick = (number, ycount, xcount) => {
                skip = false;
                if(!cpustudy){//CPUが学習中じゃない場合はターン数をカウントしない
                    round++;
                }
                if(fastturn){//一番最初にクリックをした場合は駒とモードを変更できないようにする
                    modeselect.disabled = true;
                    select.disabled = true;
                    orderselect.disabled = true;
                    fastturn = false;
                }
                masuchange(number, ycount, xcount, false);//マスの色を変更する

                if(!cpustudy){//CPUが学習中じゃない場合は駒を変更しない
                    order = (order == "白") ? "黒":"白";//クリックされて駒が変わったら順番を交代する
                    select.querySelector(`option[value='${order}']`).selected = true//交代後の駒をセット
                }
                masucheck();//マスを変更し終わったら次の駒の置ける場所を検査して赤色表示にする
            }

            let masucheck = () => {//打てるマスがあるかをチェックして赤色に表示させる関数
                let greencount = 0;
                let xcount = 0;
                let ycount = 0;
                redmasu = [];
                if(!cpustudy){
                    for(let i = 0;i<8*8;i++){
                        const number = document.getElementById(`number${i}`);
                        number.disabled = true;//一度すべての駒を打てないようにする
                        $(`#number${i}`).removeClass("onanimation");//赤色表示の削除
                        $(`#number${i}`).removeClass("cpucheckmasu");//CPUターン時の青色表示を削除
                    }
                }
                
                for(let i = 0;i<8*8;i++){//盤面が緑で返せる駒があった場合は赤色に表示する
                    if(Board[i] == 0){//0,128,0が緑、255,0,0が赤
                        masuchange(i, ycount, xcount, true)//駒チェックだけなので第４引数はtrueにする
                        if(masucheckbool){
                            if(!cpustudy){
                                const number = document.getElementById(`number${i}`);
                                number.disabled = false;//赤色に表示されているところは打てるように設定
                                $(`#number${i}`).addClass("onanimation");
                            }
                            
                            redmasu.push(i);
                            
                        }
                        greencount++;
                    }
                    xcount++;
                    if(xcount > 7){
                        xcount = 0;
                        ycount++;
                    }
                    masucheckbool = false;
                }
                if(!cpustudy){//CPUが学習中じゃない場合はリザルト表示とスキップ処理をする
                    if(greencount <= 0){//緑の盤面が0の場合はリザルトを表示
                        result();
                        return;
                    }
                    if(redmasu.length <= 0){//赤色のマスが0の場合はスキップする
                        if(skip){//白黒どっちも駒を置けなくなったら試合を強制終了する
                            result();
                            return;
                        }
                        skip = true;
                        alert(`${order}色の打つ駒がないのでスキップします`);
                        round++;
                        order = (order == "白") ? "黒":"白";//クリックされて駒が変わったら順番を交代する
                        select.querySelector(`option[value='${order}']`).selected = true//交代後の駒をセット
                        change();
                        masucheck();
                    }else{
                        if(cpumode){//CPUモードがONの場合はcpuoperationを呼び出す
                            cpuoperation();
                        }
                    }
                }
            }

            let whitePriority = 0;
            let blackPriority = 0;
            let fastorder = null;
            let kekka = -1000;
            let kekkanumber = 0;
            let studysleep = 50;
            let moto = [];
            let moto2 = [];
            let moto3 = [];
            let moto4 = [];
            let kekkaarray = [];

            //CPUのターンを確認してランダムまたは評価値をもとに赤色のマスをクリックする関数
            async function cpuoperation(){
                if(round >= 41){
                    for(let i = 0;i<Priority.length;i++){
                        Priority[i] = 1;
                    }
                }
                if(round%2 == orderchecknumber){
                    cpustudy = true;
                    moto = [];
                    moto2 = [];
                    moto3 = [];
                    moto4 = [];
                    kekkaarray = [];
                    whitePriority = 0;
                    blackPriority = 0;
                    kekka = -1000;
                    kekkanumber = 0;
                    nowturnname.textContent = "CPUのターン";
                    for(let i = 0;i<redmasu.length;i++){//CPUのターンの場合は赤色表示とクリックを無効にする
                        const number = document.getElementById(`number${redmasu[i]}`);
                        number.disabled = true;
                        $(`#number${redmasu[i]}`).removeClass("onanimation");
                    }
                    if(AImode){//AIモードの場合は処理中の文字とloading画像を表示する
                        loadingimg.setAttribute("src", "./LoadingImg/coffee.gif");
                        cpupercent.textContent = `処理中`;
                    }
                    await new Promise(resolve => setTimeout(resolve, studysleep));
                    if(AImode){
                        fastorder = order;
                        for(let j = 0;j<64;j++){
                            moto.push(Board[j]);
                        }
                        let fastredmasucount = redmasu.length;
                        for(let i = 0;i<fastredmasucount;i++){//1手先目のループ(CPUの駒)

                            AIclick(i);//クリック処理(配列の中だけで盤面は変えない)

                            //orderchange関数の第１引数は打てるマスの数で優先度を追加するかどうかを指定する
                            orderchange();//2手先予測
                            
                            for(let j = 0;j<64;j++){
                                moto2.push(Board[j]);
                            }
                            if(redmasu.length <= 0){//2手目に打つ駒がなかった場合
                                orderchange();
                                for(let j = 0;j<64;j++){
                                    moto3.push(Board[j]);
                                }
                                if(fastorder == "黒"){// パスさせた場合は優先度をプラスする
                                    blackPriority += 10;
                                }
                                loop3(i);//3手先目のループ(CPUの駒)
                            }else{
                                loop2(i);//2手先目のループ(ユーザーの駒)
                            }
                            
                            moto2 = [];
                            moto3 = [];
                            
                            const setdata = {"kekka" : kekka, "kekkanumber" : kekkanumber};
                            kekkaarray.push(setdata);
                            kekka = -1000;
                            kekkanumber = 0;
                            blackPriority = 0;
                            whitePriority = 0;

                            for(let j = 0;j<64;j++){
                                Board[j] = moto[j];
                            }
                            
                            order = fastorder;
                            masucheck();
                        }

                        order = fastorder;
                        masucheck();

                    }

                    let max = -1000;
                    let maxnumber = -1;
                    for(let i = 0;i<kekkaarray.length;i++){
                        if(kekkaarray[i]["kekka"] > max){
                            max = kekkaarray[i]["kekka"];
                            maxnumber = kekkaarray[i]["kekkanumber"];
                        }else if(kekkaarray[i]["kekka"] == max){
                            const random = Math.floor(Math.random()*2);
                            if(random == 0){
                                max = kekkaarray[i]["kekka"];
                                maxnumber = kekkaarray[i]["kekkanumber"];
                            }
                        }
                    }

                    kekka = max;
                    kekkanumber = maxnumber;

                    for(let i = 0;i<redmasu.length;i++){
                        const number = document.getElementById(`number${redmasu[i]}`);
                        number.disabled = true;//CPUのターンにユーザーが駒を打てないようにする
                        $(`#number${redmasu[i]}`).removeClass("onanimation");//赤色表示の削除
                    }
                    cpustudy = false;
                    let clicknumber = null;
                    if(AImode){
                        clicknumber = kekkanumber;
                    }else{
                        clicknumber = Math.floor(Math.random()*redmasu.length);
                    }
                    const numberdisabled = document.getElementById(`number${redmasu[clicknumber]}`);
                    numberdisabled.disabled = false;
                    $(`#number${redmasu[clicknumber]}`).addClass("cpucheckmasu");
                    if(AImode){//AIモードの場合は処理中の文字を処理完了にしてloading画像を削除
                        loadingimg.setAttribute("src", "");
                        cpupercent.textContent = "処理完了";
                    }
                    await new Promise(resolve => setTimeout(resolve, sleep))// sleep秒待つ 参考: https://qiita.com/suin/items/99aa8641d06b5f819656
                    const cpunumber = document.getElementById(`number${redmasu[clicknumber]}`).click();
                }else{
                    nowturnname.textContent = "あなたのターン";
                }
            }

            let loop2 = (icount) => {
                let loop2kekka = -1000;
                let loop2kekkanumber = -1;
                let storagekekka = kekka;
                let storagekekkanumber = kekkanumber;
                for(let j = 0;j<redmasu.length;j++){//2手先予測
                    const storageblackPriority = blackPriority;
                    const storagewhitePriority = whitePriority;

                    
                    AIclick(j);
                    orderchange();

                    //2手目(ユーザーのターン)で一番良い一手を打たれた時を計算しないといけないので
                    //loop3を呼び出して相手(AI側)の一番評価値が低かった場所に打ったことにして3手目の計算に移る
                    //参考: https://note.com/nyanyan_cubetech/n/n98c9a37a54fc?magazine_key=m54104c8d2f12#f086166e-0a82-4bc8-8529-4a43413e8a9b
                    for(let k = 0;k<64;k++){
                        moto3.push(Board[k]);
                    }
                    if(redmasu.length > 0){
                        loop3(icount);
                    }else{
                        orderchange();
                        for(let k = 0;k<64;k++){
                            moto4.push(Board[k]);
                        }
                        if(fastorder == "黒"){// パスさせた場合は優先度をプラスする
                            whitePriority += 10;
                        }
                        loop4(icount);
                    }

                    moto3 = [];
                    moto4 = [];

                    if(loop2kekkanumber < 0){
                        loop2kekka = kekka;
                        loop2kekkanumber = j;
                    }
                    if(loop2kekka > kekka){
                        loop2kekka = kekka;
                        loop2kekkanumber = j;
                    }

                    let hantei = false;//minimax法の効率化(無駄な枝をカット)参考: https://note.com/nyanyan_cubetech/n/n210cf134b8b1?magazine_key=m54104c8d2f12#22f1a1e2-5edc-4960-8594-ca02c1a12187
                    for(let k = 0;k<kekkaarray.length;k++){
                        if(kekkaarray[k]["kekka"] > kekka){
                            hantei = true;
                        }
                    }
                    
                    blackPriority = storageblackPriority;
                    whitePriority = storagewhitePriority;
                    kekka = storagekekka;
                    kekkanumber = storagekekkanumber;
                    for(let k = 0;k<64;k++){
                        Board[k] = moto2[k];
                    }
                    masucheck();

                    if(hantei){
                        return;
                    }
                }

                AIclick(loop2kekkanumber);

                orderchange();//3手先予測

                if(redmasu.length > 0){
                    for(let k = 0;k<64;k++){
                        moto3.push(Board[k]);
                    }
                    loop3(icount);
                }else{
                    orderchange();
                    for(let k = 0;k<64;k++){
                        moto4.push(Board[k]);
                    }
                    if(fastorder == "黒"){// パスさせた場合は優先度をプラスする
                        whitePriority += 10;
                    }
                    loop4(icount);
                }
                
                moto4 = [];
                moto3 = [];
            }

            let loop3 = (icount) => {
                let loop3kekka = -1000;
                let loop3kekkanumber = -1;
                let storagekekka = kekka;
                let storagekekkanumber = kekkanumber;
                for(let k = 0;k<redmasu.length;k++){//3手先目のループ(CPUの駒)
                    const storageblackPriority2 = blackPriority;
                    const storagewhitePriority2 = whitePriority;
                    
                    AIclick(k);
                    
                    orderchange();
                    
                    for(let k = 0;k<64;k++){
                        moto4.push(Board[k]);
                    }
                    if(redmasu.length > 0){
                        loop4(icount);
                        orderchange();
                    }else{
                        orderchange();
                        if(fastorder == "黒"){// パスさせた場合は優先度をプラスする
                            blackPriority += 10;
                        }
                        komacountPriority();
                        study(icount, true);
                    }
                    
                    moto4 = [];

                    if(loop3kekkanumber < 0){
                        loop3kekka = kekka;
                        loop3kekkanumber = k;
                    }
                    if(loop3kekka < kekka){
                        loop3kekka = kekka;
                        loop3kekkanumber = k;
                    }
                    
                    blackPriority = storageblackPriority2;
                    whitePriority = storagewhitePriority2;
                    kekka = storagekekka;
                    kekkanumber = storagekekkanumber;

                    for(let l = 0;l<64;l++){
                        Board[l] = moto3[l];
                    }
                    masucheck();
                }

                AIclick(loop3kekkanumber);

                orderchange();//4手先予測

                if(redmasu.length > 0){
                    for(let k = 0;k<64;k++){
                        moto4.push(Board[k]);
                    }
                    loop4(icount);
                }else{
                    if(fastorder == "黒"){// パスさせた場合は優先度をプラスする
                        blackPriority += 10;
                    }
                    study(icount, true);
                }

                moto4 = [];    
            }

            let loop4 = (icount) => {
                let loop4kekka = -1000;
                let loop4kekkanumber = -1;
                let storagekekka = kekka;
                let storagekekkanumber = kekkanumber;
                for(let i = 0;i<redmasu.length;i++){//4手先のループ(ユーザーの駒)
                    const storageblackPriority3 = blackPriority;
                    const storagewhitePriority3 = whitePriority;

                    komacountPriority();
                    
                    AIclick(i);

                    orderchange();
                    komacountPriority();

                    study(icount, true);

                    if(loop4kekkanumber < 0){
                        loop4kekka = kekka;
                        loop4kekkanumber = i;
                    }
                    if(loop4kekka > kekka){
                        loop4kekka = kekka;
                        loop4kekkanumber = i;
                    }

                    blackPriority = storageblackPriority3;
                    whitePriority = storagewhitePriority3;
                    kekka = storagekekka;
                    kekkanumber = storagekekkanumber;

                    for(let l = 0;l<64;l++){
                        Board[l] = moto4[l];
                    }
                    orderchange();
                }

                AIclick(loop4kekkanumber);

                study(icount, true);
            }

            let AIclick = (loopcount) =>{
                let ycount = Math.floor(redmasu[loopcount]/8);
                let xcount = redmasu[loopcount]%8;
                viewclick(redmasu[loopcount], ycount, xcount);
            }

            let orderchange = () => {
                order = (order == "黒") ? "白":"黒";
                masucheck();
            }

            //置ける駒数の多さで評価値を加算する関数
            let komacountPriority = () => {
                if(order = "黒"){//置ける駒数の多さで評価値を加算するに変更
                    if(redmasu.length <= 0){
                        whitePriority += 10;
                    }
                    blackPriority += redmasu.length;
                }else{
                    if(redmasu.length <= 0){
                        blackPriority += 10;
                    }
                    whitePriority += redmasu.length;
                }
            }

            let study = (icount, final) => {
                for(let i = 0;i<64;i++){
                    if(Board[i] == 2){
                        blackPriority += Priority[i];
                    }else if(Board[i] == 1){
                        whitePriority += Priority[i];
                    }
                }

                if(final){
                    let count = 0;
                    let color = -1;
                    //確定石の計算
                    for(let i = 0;i<8;i++){
                        if(i == 0){
                            for(let j = 0;j<7;j++){
                                if(Board[0] == 0){
                                    break;
                                }
                                if(Board[j] == 0){
                                    if(j == 1 && color != 0){
                                        count++;
                                    }
                                    break;
                                }
                                color = Board[0];
                                if(color != Board[j]){
                                    break;
                                }
                                if(Board[j] == Board[j+1]){
                                    count += 2;
                                }
                            }
                        }else if(i == 1){
                            for(let j = 7;j>0;j--){
                                if(Board[7] == 0){
                                    break;
                                }
                                if(Board[j] == 0){
                                    if(j == 6 && color != 0){
                                        count++;
                                    }
                                    break;
                                }
                                color = Board[7];
                                if(color != Board[j]){
                                    break;
                                }
                                if(Board[j] == Board[j-1]){
                                    count += 2;
                                }
                            }
                        }else if(i == 2){
                            for(let j = 0;j<7;j++){
                                if(Board[56] == 0){
                                    break;
                                }
                                if(Board[56+j] == 0){
                                    if(j == 1 && color != 0){
                                        count++;
                                    }
                                    break;
                                }
                                color = Board[56];
                                if(color != Board[56+j]){
                                    break;
                                }
                                if(Board[56+j] == Board[56+j+1]){
                                    count += 2;
                                }
                            }
                        }else if(i == 3){
                            for(let j = 0;j<7;j++){
                                if(Board[63] == 0){
                                    break;
                                }
                                if(Board[63-j] == 0){
                                    if(j == 1 && color != 0){
                                        count++;
                                    }
                                    break;
                                }
                                color = Board[63];
                                if(color != Board[63-j]){
                                    break;
                                }
                                if(Board[63-j] == Board[63-j-1]){
                                    count += 2;
                                }
                            }
                        }else if(i == 4){
                            for(let j = 0;j<7;j++){
                                if(Board[0] == 0){
                                    break;
                                }
                                if(Board[j*8] == 0){
                                    if(j == 1 && color != 0){
                                        count++;
                                    }
                                    break;
                                }
                                color = Board[0];
                                if(color != Board[j*8]){
                                    break;
                                }
                                if(Board[j*8] == Board[j*8+8]){
                                    count += 2;
                                }
                            }
                        }else if(i == 5){
                            for(let j = 0;j<7;j++){
                                if(Board[56] == 0){
                                    break;
                                }
                                if(Board[56-j*8] == 0){
                                    if(j == 1 && color != 0){
                                        count++;
                                    }
                                    break;
                                }
                                color = Board[56];
                                if(color != Board[56-j*8]){
                                    break;
                                }
                                if(Board[56-j*8] == Board[56-j*8-8]){
                                    count += 2;
                                }
                            }
                        }else if(i == 6){
                            for(let j = 0;j<7;j++){
                                if(Board[7] == 0){
                                    break;
                                }
                                if(Board[7+j*8] == 0){
                                    if(j == 1 && color != 0){
                                        count++;
                                    }
                                    break;
                                }
                                color = Board[7];
                                if(color != Board[7+j*8]){
                                    break;
                                }
                                if(Board[7+j*8] == Board[7+j*8+8]){
                                    count += 2;
                                }
                            }
                        }else if(i == 7){
                            for(let j = 0;j<7;j++){
                                if(Board[63] == 0){
                                    break;
                                }
                                if(Board[63-j*8] == 0){
                                    if(j == 1 && color != 0){
                                        count++;
                                    }
                                    break;
                                }
                                color = Board[63];
                                if(color != Board[63-j*8]){
                                    break;
                                }
                                if(Board[63-j*8] == Board[63-j*8-8]){
                                    count += 2;
                                }
                            }
                        }

                        if(color == 1){
                            whitePriority += count;
                        }else if(color == 2){
                            blackPriority += count;
                        }
                        count = 0;
                        color = -1;
                    }
                    
                    if(fastorder == "黒"){
                        if(blackPriority - whitePriority > kekka){
                            kekka = blackPriority - whitePriority;
                            kekkanumber = icount
                        }
                    }else{
                        if(whitePriority - blackPriority > kekka){
                            kekka = whitePriority - blackPriority;
                            kekkanumber = icount
                        }
                    }
                }
            }

            let result = (redmasu) => {//リザルトを表示させる関数
                let whitecount = 0;
                let blackcount = 0;
                let win = "";
                for(let i = 0;i<8*8;i++){
                    const number = document.getElementById(`number${i}`);
                    if(number.style.backgroundColor == "black"){
                        blackcount++;
                    }else if(number.style.backgroundColor == "white"){
                        whitecount++;
                    }
                }
                if(whitecount > blackcount){
                    win = "白の勝利";
                }else if(whitecount < blackcount){
                    win = "黒の勝利";
                }else{
                    win = "引き分け";
                }
                const viewresult = document.querySelector('.result');
                viewresult.textContent = `白${whitecount}枚 : 黒${blackcount}枚`;
                viewresult.insertAdjacentHTML("beforeend", `<br><span class="result">${win}</span>`);
                $(".resetbutton").addClass("onresetanimation");
            }

            //駒が置かれたときに返す駒が何個あるかを判定する関数
            let onclickmasucheck = (number, count) => {
                if(whitehantei && number == 2){//端が白でその間が黒のかどうかを一つずつ検査
                    count++;
                }else if(blackhantei && number == 1){//端が黒で白を検査
                    count++;
                }else{
                    if(order == "白" && number == 1){//置いた駒が白で現在検査している駒が白の場合はその間が黒かを検査するwhitehantei変数をtrueにする
                        whitehantei = true;
                        count = 0;//連続で白が出た場合はカウントをリセット
                    }else if(order == "黒" && number == 2){//上の黒バージョン
                        blackhantei = true;
                        count = 0;
                    }else{
                        whitehantei = false;//盤面が緑の場合はカウントと間かどうかチェックする判定をリセット
                        blackhantei = false;
                        count = 0;
                    }
                }
                return count;
            }


            //左横方向の駒を検査して色を変更
            let xminus = (number, ycount, xcount, check) => {
                let count = 0;
                whitehantei = false;
                blackhantei = false;
                for(let i = xcount;xcount>xcount-i;i--){//x座標0から現在の座標まで(左から)を検査
                    count = onclickmasucheck(Board[number-i], count);
                }
                if(count >= 1){//カウントが1以上(返す盤面がある)場合は色を変更する
                    if(check){
                        //打てる駒をチェックする用に呼び出された場合カウントが１以上なので変数にtrueを代入してreturnでこの関数の処理を強制終了する
                        masucheckbool = true;
                        return;
                    }

                    if(order == '白'){
                        Board[number] = 1;
                        for(let j = 1;j<=count;j++){
                            Board[number-j] = 1;
                        }
                    }else{
                        Board[number] = 2;
                        for(let j = 1;j<=count;j++){
                            Board[number-j] = 2;
                        }
                    }
                }
            }

            //右方向の駒を検査して色を変更
            let xplus = (number, ycount, xcount, check) => {
                let count = 0;
                whitehantei = false;
                blackhantei = false;
                let sa = 7-xcount;
                for(let i = sa;0<i;i--){//現在のx座標から横幅を引いて(右から)検査
                    count = onclickmasucheck(Board[number+i], count);
                }
                if(count >= 1){
                    if(check){
                        masucheckbool = true;
                        return;
                    }

                    if(order == '白'){
                        Board[number] = 1;
                        for(let j = 1;j<=count;j++){
                            Board[number+j] = 1;
                        }
                    }else{
                        Board[number] = 2;
                        for(let j = 1;j<=count;j++){
                            Board[number+j] = 2;
                        }
                    }
                }
            }

            //下方向の駒を検査して色を変更
            let yminus = (number, ycount, xcount, check) => {
                let count = 0;
                whitehantei = false;
                blackhantei = false;
                let sa = 7-ycount;
                for(let i = sa;0<i;i--){//現在のy座標から縦幅を引いて(下から上に)検査
                    count = onclickmasucheck(Board[number+i*8], count);//一段ずつ上がってくるように8をかける
                }
                if(count >= 1){
                    if(check){
                        masucheckbool = true;
                        return;
                    }

                    if(order == '白'){
                        Board[number] = 1;
                        for(let j = 1;j<=count;j++){
                            Board[number+j*8] = 1;
                        }
                    }else{
                        Board[number] = 2;
                        for(let j = 1;j<=count;j++){
                            Board[number+j*8] = 2;
                        }
                    }
                }
            }

            //上方向の駒の検査して色を変更
            let yplus = (number, ycount, xcount, check) => {
                let count = 0;
                whitehantei = false;
                blackhantei = false;
                for(let i = ycount;ycount>ycount-i;i--){//y座標0から現在のy座標まで(上から下)を検査
                    count = onclickmasucheck(Board[number-8*i], count);//一段ずつ下がってくるように8をかける
                }
                if(count >= 1){
                    if(check){
                        masucheckbool = true;
                        return;
                    }

                    if(order == '白'){
                        Board[number] = 1;
                        for(let j = 1;j<=count;j++){
                            Board[number-8*j] = 1;
                        }
                    }else{
                        Board[number] = 2;
                        for(let j = 1;j<=count;j++){
                            Board[number-8*j] = 2;
                        }
                    }
                }
            }

            //左斜め下の駒の検査して色を変更
            let BottomLeft = (number, ycount, xcount, check) => {
                let count = 0;
                whitehantei = false;
                blackhantei = false;
                for(let i = xcount;0<i;i--){//現在のx座標から左斜めを検査
                    if(number+i*7 > Board.length){
                        continue;//x座標を使って検査すると盤面の範囲を超えて検査してしまうのでnullの場合はbreakする
                    }
                    count = onclickmasucheck(Board[number+i*7], count);//左斜め下はnumber+i*7
                }
                if(count >= 1){
                    if(check){
                        masucheckbool = true;
                        return;
                    }

                    if(order == '白'){
                        Board[number] = 1;
                        for(let j = 1;j<=count;j++){
                            Board[number+j*7] = 1;
                        }
                    }else{
                        Board[number] = 2;
                        for(let j = 1;j<=count;j++){
                            Board[number+j*7] = 2;
                        }
                    }
                }
            }

            //右斜め上の駒の検査して色を変更
            let UpperRight = (number, ycount, xcount, check) => {
                let count = 0;
                whitehantei = false;
                blackhantei = false;
                let sa = 7-xcount;
                for(let i = sa;0<i;i--){//右方向の検査なので縦横の時と同じように現在の座標から横幅を引いて検査することま指定する
                    if(number-i*7 < 0){
                        continue;
                    }
                    count = onclickmasucheck(Board[number-i*7], count);
                }
                if(count >= 1){
                    if(check){
                        masucheckbool = true;
                        return;
                    }

                    if(order == '白'){
                        Board[number] = 1;
                        for(let j = 1;j<=count;j++){
                            Board[number-j*7] = 1;
                        }
                    }else{
                        Board[number] = 2;
                        for(let j = 1;j<=count;j++){
                            Board[number-j*7] = 2;
                        }
                    }
                }
            }

            //右斜め下の駒の検査して色を変更
            let BottomRight = (number, ycount, xcount, check) => {
                let count = 0;
                whitehantei = false;
                blackhantei = false;
                let sa = 7-xcount;
                for(let i = sa;0<i;i--){
                    if(number+i*9 > Board.length){
                        continue;
                    }
                    count = onclickmasucheck(Board[number+i*9], count);
                }
                if(count >= 1){
                    if(check){
                        masucheckbool = true;
                        return;
                    }

                    if(order == '白'){
                        Board[number] = 1;
                        for(let j = 1;j<=count;j++){
                            Board[number+j*9] = 1;
                        }
                    }else{
                        Board[number] = 2;
                        for(let j = 1;j<=count;j++){
                            Board[number+j*9] = 2;
                        }
                    }
                }
            }

            //左斜め上の駒の検査して色を変更
            let UpperLeft = (number, ycount, xcount, check) => {
                let count = 0;
                whitehantei = false;
                blackhantei = false;
                for(let i = xcount;0<i;i--){
                    if(number-i*9 < 0){
                        continue;
                    }
                    count = onclickmasucheck(Board[number-i*9], count);
                }
                if(count >= 1){
                    if(check){
                        masucheckbool = true;
                        return;
                    }

                    if(order == '白'){
                        Board[number] = 1;
                        for(let j = 1;j<=count;j++){
                            Board[number-j*9] = 1;
                        }
                    }else{
                        Board[number] = 2;
                        for(let j = 1;j<=count;j++){
                            Board[number-j*9] = 2;
                        }
                    }
                }
            }

            let reset = () => {
                location.reload();
            }

            createbox();//盤面の生成
        </script>
    </body>
</html>